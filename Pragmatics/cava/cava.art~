(*****************************************************************************************************************************
*
* ARTCavaParser.art - Adrian Johnstone
*
* A dynamically typed language which uses ART's Value types
*
* Developed by Adrian Johnstone with support from:
*
* Leverhulme Trust project grant RPG-2013-396 'Notions and notations; Babbage's Language of Thought'
*
* and
*
* EPSRC project EP/I032509/1 'PLanCompS: Programming Language Components and Specifications'
*
******************************************************************************************************************************)

(* Prelude material **********************************************************************************************************)
!prelude{import java.math.BigInteger;}

!whitespace &SIMPLE_WHITESPACE
!whitespace &COMMENT_BLOCK_C
!whitespace &COMMENT_LINE_C 

!support 
{ 
/* Signals: support classes for exception throwing */
@SuppressWarnings("serial")
public class ARTCavaSignalBreak extends ARTException {

  public ARTCavaSignalBreak(String message) {
    super(message);
  }

  public ARTCavaSignalBreak() {
    this("");
  }
}

@SuppressWarnings("serial")
public class ARTCavaSignalContinue extends ARTException {

  public ARTCavaSignalContinue(String message) {
    super(message);
  }

  public ARTCavaSignalContinue() {
    this("");
  }
}

@SuppressWarnings("serial")
public class ARTCavaSignalReturn extends ARTException {
  private Value value;

  public ARTCavaSignalReturn(String message) {
    super(message);
  }

  public ARTCavaSignalReturn() {
    this("");
  }

@SuppressWarnings("serial")
public ARTCavaSignalReturn(Value value) {
    this("");
    this.value = value;
  }

  public Value getValue() {
    return value;
  }
}

@SuppressWarnings("serial")
public class ARTCavaSignalYield extends ARTException {
  private Value value;

  public ARTCavaSignalYield(String message) {
    super(message);
  }

  public ARTCavaSignalYield() {
    this("");
  }

  public ARTCavaSignalYield(Value value) {
    this("");
    this.value = value;
  }

  public Value getValue() {
    return value;
  }
}

/* Globals */

  ITerms iTerms = new ITermsLowLevelAPI();

  // Some useful constant aliases
  final __intAP ADDRESSnull = iTerms.valueIntAPZero;
  final __intAP ADDRESSincrement  = iTerms.valueIntAPOne;
  final __bottom BOTTOM = iTerms.valueBottom;
  final __empty EMPTY = iTerms.valueEmpty; 
  final __int32 ZERO = iTerms.valueInt32Zero; 
  final __int32 ONE = iTerms.valueInt32One; 
  final __bool TRUE = iTerms.valueBoolTrue; 
  final __bool FALSE = iTerms.valueBoolTrue; 

  // Predefined I/O streams
  Value stdin = new __input(System.in);
  Value stdout = new __output(System.out);

  // Environment, store, and store address allocation
  __mapChain env = new __mapChain(); 
  __map store = new __map();
  Value nextFreeStoreAddress = new __intAP(new BigInteger("1")); // Start at 1: zero is reserved for NULL address

  // Create a binding in an environment
  void bindVariable(__mapChain env, Value id, Value value) throws ARTException {
  //  System.out.println("Binding " + id + " to " + value);     
    if ((boolean) env.__contains(id).value()) throw new ARTException("attempt to rebind variable " + id);
    env.__put(id, value);
  }

  // Allocate an element of the store and initialise it
  Value storeAllocate(Value value) throws ARTException {
    Value ret = nextFreeStoreAddress;
  //  System.out.println("Allocating store address " + nextFreeStoreAddress + " and initialising to " + value);     
    store.__put(nextFreeStoreAddress, value); 
    nextFreeStoreAddress = nextFreeStoreAddress.__add(ADDRESSincrement); 
    return ret;
  }

 // Find a variable in the current environment and update it
  void storeVariable(__mapChain env, Value id, Value value) throws ARTException {
  //  System.out.println("Storing " + value + " in variable " + id);     
    if (!((boolean) env.__contains(id).value())) { 
    //  System.out.println("In store, binding " + id + " to store address " + nextFreeStoreAddress);     
      bindVariable(env, id, nextFreeStoreAddress); 
      store.__put(nextFreeStoreAddress, BOTTOM); 
      nextFreeStoreAddress = nextFreeStoreAddress.__add(ADDRESSincrement); 
    }
    store.__put(env.__get(id), value);
  }

  Value dereferenceVariable(__mapChain env, Value id) throws ARTException {
    // System.out.println("Dereferencing " + id);     
    if (!((boolean) env.__contains(id).value())) throw new ARTException("Unknown variable " + id);
    Value ret = env.__get(id);
    //  System.out.println(id + " dereferenced to binding " + ret);     
    if (ret instanceof __intAP) {
      ret = store.__get(ret);
    //  System.out.println(id + " dereferenced to store value " + ret);     
    }
    return ret;
  }
}

(* Command grammar  **********************************************************************************************************)

text ::= { System.out.println("Standard V4 Cava interpreter"); } 
         statements 
         { System.out.println("Final environment " + env);
           System.out.println("Final store " + store);
         }

statements ::= 
  statement 
| statement  statements

statement ::= expr ';'  

| 'if' expr statement< elseOpt<             (* if statement *)
  { if (expr1.v.equals(TRUE)) artEvaluate(statement.statement1, statement1); 
    else                      artEvaluate(statement.elseOpt1, elseOpt1);
  }

| 'while' expr<  statement<                 (* while statement *)
  { try {
      artEvaluate(statement.expr1, expr1); 
      while (expr1.v.equals(TRUE)) {
        try { artEvaluate(statement.statement1, statement1); } catch (ARTCavaSignalContinue s) {}
        artEvaluate(statement.expr1, expr1); 
      }
    } catch (ARTCavaSignalBreak s) {}
  }  

| 'for' '(' expr< ';' expr< ';' expr< ')' statement< (* for statement *)
  { artEvaluate(statement.expr1, expr1);        // perform initialisation
    artEvaluate(statement.expr2, expr2);        // perform first test
    while (expr2.v.equals(TRUE)) { 
      artEvaluate(statement.statement1, statement1);
      artEvaluate(statement.expr3, expr3);      // perform increment 
      artEvaluate(statement.expr2, expr2);      // perform test 
    }  
  }         

| '{' statements '}'                                 (* compound statement *)

| 'class' ID statements                              (* class extending Object *)

| 'class' ID 'extends' ID statements                 (* class extending class *)

| 'class' ID 'with' ID statements                    (* class with mixin class *)

elseOpt ::= 
  'else' statement
| #     

(* End of command grammar ****************************************************************************************************)


(* Environment and store access ***********************************************************************************************)

bindVariableAccess <v> ::= ID  { bindVariable(env, ID1.v, bindVariableAccess.v); }

assignVariableAccess <v> ::= ID  { storeVariable(env, ID1.v, assignVariableAccess.v); }

(* Expression grammar *********************************************************************************************************)

expr <v> ::= seq    { expr.v = seq1.v; }

seq <v> ::=
  bind                  { seq.v = bind1.v; } 
| seq ';;' bind         { seq.v = bind1.v; } 
 
bind <v> ::=
  assign                { bind.v = assign1.v; } 
| bindVariableAccess< '=' assign  { bind.v = assign1.v; bindVariableAccess1.v = assign1.v; artEvaluate(bind.bindVariableAccess1, bindVariableAccess1); }

(* The sublanguage of the assign nontermimal is not right - only := alone looks plausible *)

assign <v> ::=
  lambda                { assign.v = lambda1.v; }
| assignVariableAccess< ':=' lambda { assign.v = lambda1.v; assignVariableAccess1.v = lambda1.v; artEvaluate(assign.assignVariableAccess1, assignVariableAccess1); } (* assignment *)
| ID '+='   assign      { assign.v = assign1.v.__add(store.__get(env.__get(ID1.v))); }           
| ID '-='   assign      { assign.v = assign1.v.__sub(store.__get(env.__get(ID1.v))); }           
| ID '*='   assign      { assign.v = assign1.v.__mul(store.__get(env.__get(ID1.v))); }           
| ID '/='   assign      { assign.v = assign1.v.__div(store.__get(env.__get(ID1.v))); }           
| ID '%='   assign      { assign.v = assign1.v.__mod(store.__get(env.__get(ID1.v))); }           
| ID '&='   assign      { assign.v = assign1.v.__and(store.__get(env.__get(ID1.v))); }           
| ID '^='   assign      { assign.v = assign1.v.__xor(store.__get(env.__get(ID1.v))); }           
| ID '|='   assign      { assign.v = assign1.v.__or(store.__get(env.__get(ID1.v))); }           
| ID '<<='  assign      { assign.v = assign1.v.__lsh(store.__get(env.__get(ID1.v))); }           
| ID '>>='  assign      { assign.v = assign1.v.__rsh(store.__get(env.__get(ID1.v))); }           
| ID '>>>=' assign      { assign.v = assign1.v.__ash(store.__get(env.__get(ID1.v))); }           

lambda <v> ::= (* Make procedure *)
  iter                  { lambda.v = iter1.v; } 
| "\\" '(' formals ')' '{' statements< '}' { lambda.v = new __procV3(formals1.parameters, formals1.defaults, lambda.statements1); }    

iter <v> ::=   (* Iteration *)
  sel                   { iter.v = sel1.v; }
| sel '??' iter         { iter.v = sel1.v; } (* TO DO *) 
| sel '??' iter '!!' iter { iter.v = sel1.v; } (* TO DO *)

sel <v> ::=    (* Selection *)
  or                   { sel.v = or1.v; }
| or '?' sel           { sel.v = or1.v; } (* TO DO *) 
| or '?' sel '!!' sel  { sel.v = or1.v; } (* TO DO *)

or <v> ::=   (* logical inclusive OR (disjunction) *)
 xor                  { or.v =xor1.v; } 
| or '|' xor          { or.v = or1.v.__or(xor1.v); } 

xor <v> ::=  (* logical exclusive OR *)
  and                 { xor.v = and1.v; } 
| xor '^' and         { xor.v = xor1.v.__xor(and1.v); } 

and <v> ::=  (* logical AND (conjunction) *)
  equ                 { and.v = equ1.v; } 
| equ '&' and         { and.v = and1.v.__and(equ1.v); } 

equ <v> ::=  (* equality *)
  rel                 { equ.v = rel1.v; } 
| rel '==' rel        { equ.v = rel1.v.__eq(rel2.v); }    (* equal *) 
| rel '!=' rel        { equ.v = rel1.v.__ne(rel2.v); }    (* not equal *)

rel <v> ::=  (* relational *)
  cat                 { rel.v = cat1.v; } 
| cat '>=' cat        { rel.v = cat1.v.__ge(cat2.v); }    (* Greater than *)
| cat '>' cat         { rel.v = cat1.v.__gt(cat2.v); }    (* Greater *)
| cat '<=' cat        { rel.v = cat1.v.__le(cat2.v); }    (* Less than *)
| cat '<' cat         { rel.v = cat1.v.__lt(cat2.v); }    (* Less *)

cat <v> ::=  (* list concatenation *)
  shift               { cat.v = shift1.v; } 
| cat '::' shift      { cat.v = cat1.v.__cat(shift1.v); }         (* Concatenate *)

shift <v> ::=  (* bitwise shifts and rotates *)
  add                 { shift.v = add1.v; } 
| shift  '<<' add   { if (shift1.v instanceof __output) shift.v = shift1.v.__put(add1.v);  else shift.v = shift1.v.__lsh(add1.v); }   (* Left shift *)
| shift  '>>' add   { if (shift1.v instanceof __input) shift.v = shift1.v.__get(add1.v);  else shift.v = shift1.v.__rsh(add1.v); }   (* Right shift *)
| shift  '<<|' add    { shift.v = shift1.v.__rol(add1.v); }   (* Rotate left *)
| shift  '>>|' add    { shift.v = shift1.v.__ror(add1.v); }   (* Rotate right *)
| shift  '>>>' add    { shift.v = shift1.v.__ash(add1.v); }   (* Arithmetic shift *)

add <v> ::=  (* addition and subtraction *)
  mul                 { add.v = mul1.v; } 
| add '+' mul         { add.v = add1.v.__add(mul1.v); }         (* Add *)
| add '-' mul         { add.v = add1.v.__sub(mul1.v); }         (* Subtract *)

mul <v> ::=  (* multiplication, division and remainder *)
  exp                 { mul.v = exp1.v; } 
| mul '*' exp         { mul.v = mul1.v.__mul(exp1.v); }         (* Multiply *)
| mul '/' exp         { mul.v = mul1.v.__div(exp1.v); }         (* Divide *)
| mul '%' exp         { mul.v = mul1.v.__mod(exp1.v); }         (* Remainder *)

exp <v> ::=  (* exponentitation *)
  op                  { exp.v = op1.v; } 
| exp '**' op         { exp.v = exp1.v.__exp(op1.v); }         (* Exponentiate *)

op <v> ::=   (* unary operators, includind constructors for built in types *)
  doFirst             { op.v = doFirst1.v; } 
| '+' op              { op.v = op1.v; }                       (* Posite *)
| '++' op             { op.v = op1.v.__add(ONE); }            (* Preincrement *)
| op '++'             { op.v = op1.v.__add(ONE); }            (* Postincrement *)
| '-' op              { op.v = op1.v.__neg(); }               (* Negate *)
| '--' op             { op.v = op1.v.__sub(ONE); }            (* Predecrement *)
| op '--'             { op.v = op1.v.__sub(ONE); }            (* Postdecrement *)
| '!' op              { op.v = op1.v.__not(); }               (* Logical invert *)
| '_'                                                         (* nonbinding metavariable *)
| 'empty'             { op.v= EMPTY; }                        (* empty literal *)
| 'BOTTOM'            { op.v= BOTTOM; }                       (* bottom literal *)
| 'true'              { op.v = TRUE;}                         (* Boolean literal true *) 
| 'false'             { op.v = FALSE;}                        (* Boolean  literal false *)
| INTEGER             { op.v = INTEGER1.v; }                  (* Integer literal *)
| REAL                { op.v = REAL1.v; }                     (* Real literal *)
| CHARACTER           { op.v = CHARACTER1.v; }                (* Character literal *)
| STRING              { op.v = STRING1.v; }                   (* String literal *)
| ID                  { op.v = dereferenceVariable(env, ID1.v); } (* Variable access *)
| ID '(' unnamedActuals namedActuals ')'                                          (* Procedure call *)  
  { __procV3 proc = (__procV3) dereferenceVariable(env, ID1.v);
    env = proc.buildEnvironment(env, unnamedActuals1.parameters, namedActuals1.parameters, namedActuals1.defaults);
    try { artEvaluate(proc.getStatements(), new ARTAT_ART_statements()); } 
      catch (ARTCavaSignalReturn s) { op.v = s.getValue(); }
      catch (ARTCavaSignalYield s)  { op.v = s.getValue(); } /* In this implementation, treat yield as return */
    env = env.getPayload2();  /* Reset stack frame to parent */
  }
| 'break'       { if (true) throw new ARTCavaSignalBreak(); } (* The redundant if(true) is added so as to defeat Java's control flow analysis *)
| 'continue'    { if (true) throw new ARTCavaSignalContinue(); }
| 'return'      { if (true) throw new ARTCavaSignalReturn(BOTTOM); }
| 'return' expr { if (true) throw new ARTCavaSignalReturn(expr1.v); }
| 'yield' expr  { if (true) throw new ARTCavaSignalYield(BOTTOM); }
| 'yield' expr  { if (true) throw new ARTCavaSignalYield(expr1.v); }
| 'input' '(' ')' { /* op.v = stdin.scanRich(); */ }
| 'output' '(' expr ')' { op.v = expr1.v; stdout.__put(expr1.v); }
| 'cin'   { /* op.v = new ValueStream(System.in, "stdin"); */ }                           (* Standard output stream *)
| 'cout'  { op.v = stdout; } (* Standard output stream *)                                    (* Standard input stream *) 

doFirst <v> ::=
  '(' expr ')'        { doFirst.v = expr1.v; } 

(* End of expression grammar *************************************************************************************************)

(* Formal and actual argument handling ***************************************************************************************)

formals<parameters defaults> ::= 
  # { formals.parameters = new __list(); formals.defaults = new __list(); }

| ID          { formals.parameters = new __list().__cat(ID1.v); formals.defaults = new __list().__cat(iTerms.valueEmpty); }         
| ID ':' expr { formals.parameters = new __list().__cat(ID1.v); formals.defaults =  new __list().__cat(expr1.v); }         

| ID ',' formals { formals.parameters = formals1.parameters.__cat(ID1.v); formals.defaults = formals1.defaults.__cat(iTerms.valueEmpty); }         
| ID ':' expr ',' formals { formals.parameters = formals1.parameters.__cat(ID1.v); formals.defaults = formals1.defaults.__cat(expr1.v); }         

unnamedActuals<parameters> ::=
  # { unnamedActuals.parameters = new __list(); }
| expr { unnamedActuals.parameters = new __list().__cat(expr1.v); }
| expr ',' unnamedActuals { unnamedActuals.parameters = unnamedActuals1.parameters.__cat(expr1.v); }

namedActuals<parameters defaults> ::= 
  # { namedActuals.parameters = new __list(); namedActuals.defaults = new __list(); }
| ID ':' expr { namedActuals.parameters = new __list().__cat(ID1.v); namedActuals.defaults = new __list().__cat(expr1.v); }
| ID ':' expr ',' namedActuals { namedActuals.parameters = namedActuals1.parameters.__cat(ID1.v); namedActuals.defaults = namedActuals1.defaults.__cat(expr1.v); }

(* End of formal and actual argument handling ********************************************************************************)

(* Lexical syntax ************************************************************************************************************)

ID <v leftExtent:int rightExtent:int> ::=  &ID^ { ID.v = new __string(artLexemeAsID(ID.leftExtent, ID.rightExtent)); }
INTEGER <v leftExtent:int rightExtent:int> ::= &INTEGER^ { INTEGER.v = new __int32(artLexemeAsInteger(INTEGER.leftExtent, INTEGER.rightExtent), 0); }
REAL <v leftExtent:int rightExtent:int> ::= &REAL^ {REAL.v = new __real64(artLexemeAsReal(REAL.leftExtent, REAL.rightExtent)); }
CHARACTER <v leftExtent:int rightExtent:int> ::= &STRING_SQ^ {CHARACTER.v = new __char(artLexemeAsString(CHARACTER.leftExtent, CHARACTER.rightExtent).charAt(0)); } 
STRING <v leftExtent:int rightExtent:int> ::= &STRING_DQ^ {STRING.v = new __string(artLexemeAsString(STRING.leftExtent, STRING.rightExtent)); }

(* End of lexical syntax *****************************************************************************************************)

