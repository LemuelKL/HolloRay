statement ::= seq^^ | assign^^ | if^^ | while^^ | backend^^ | print^^ | init^^ | paint^^

seq ::= statement statement
assign ::= ID '='^ subExpr ';'^
if ::= 
    'if'^ '('^ relExpr ')'^ statement 'else'^ statement 'fi'^
  | 'if'^ '('^ relExpr ')'^ statement 'fi'^
while ::= 'while'^ relExpr statement
backend ::= 'backend'^ '('^ subExpr ','^ subExpr ','^ subExpr ')'^
print ::= 'print'^ '('^ subExpr  ')'^ ';'^
init ::= 'init'^ '('^ INTEGER ','^ INTEGER  ')'^ ';'^
paint ::= 'paint'^ '('^ ')'^ ';'^

relExpr ::= subExpr^^ | gt^^ | ne^^ | lt^^ | eq^^
gt ::= relExpr '>'^ subExpr
ne ::= relExpr '!='^ subExpr
lt ::= relExpr '<'^ subExpr
eq ::= relExpr '=='^ subExpr

subExpr ::= operand^^ | sub^^ | add^^ | mul^^ | div^^
sub ::= subExpr '-'^ operand
add ::= subExpr '+'^ operand
mul ::= subExpr '*'^ operand
div ::= subExpr '/'^ operand

operand ::= deref^^ | INTEGER^^ | REAL^^ | STRING_DQ^^ | '('^ subExpr^^ ')'^
deref ::= ID

(* lexical items below this line *)
ID <leftExtent:int rightExtent:int lexeme:String v:ARTValueString> ::=
  &ID^^ {ID.lexeme = artLexeme(ID.leftExtent, ID.rightExtent);
  ID.v = new ARTValueString(artLexemeAsID(ID.leftExtent, ID.rightExtent)); }

INTEGER <leftExtent:int rightExtent:int lexeme:String v:ARTValueInteger32> ::=
  &INTEGER^^ { INTEGER.lexeme = artLexeme(INTEGER.leftExtent, INTEGER.rightExtent);
  INTEGER.v = new ARTValueInteger32(artLexemeAsInteger(INTEGER.leftExtent, INTEGER.rightExtent)); }

REAL <leftExtent:int rightExtent:int lexeme:String v:double> ::=
&REAL^^ {REAL.lexeme = artLexeme(REAL.leftExtent, REAL.rightExtent);
REAL.v = artLexemeAsInteger(REAL.leftExtent, REAL.rightExtent); }

STRING_DQ <leftExtent:int rightExtent:int lexeme:String v:String> ::=
&STRING_DQ^^ {STRING_DQ.lexeme = artLexeme(STRING_DQ.leftExtent, STRING_DQ.rightExtent);
STRING_DQ.v = artLexemeAsString(STRING_DQ.leftExtent, STRING_DQ.rightExtent); }
